import { existsSync, mkdirSync, readFileSync, statSync, writeFileSync } from 'node:fs';
import { createRequire } from 'node:module';
import { basename, dirname, extname, join } from 'node:path';
import { cwd, env } from 'node:process';
import { findUpSync } from 'find-up';
import { BLUEPRINT_CONFIG_FILE, BLUEPRINT_CONFIG_VERSION, BLUEPRINT_DIR } from '../../config.js';
import { isLocalFunctionResource } from '../../utils/types.js';
import { validateFunctionResource } from '../../utils/validate/resource.js';
import { blueprintParserValidator } from '../../utils/vendor/parser-validator.js';
export { BLUEPRINT_CONFIG_FILE, BLUEPRINT_CONFIG_VERSION, BLUEPRINT_DIR } from '../../config.js';
const SUPPORTED_FILE_EXTENSIONS = ['.json', '.js', '.mjs', '.cjs', '.ts'];
const SUPPORTED_FILE_NAMES_IN_PRIORITY_ORDER = SUPPORTED_FILE_EXTENSIONS.map((ext) => `blueprint${ext}`);
export const DEFAULT_BLUEPRINT_CONTENT = {
    blueprintVersion: '2024-10-01',
    resources: [],
};
/**
 * Finds the blueprint file in the given path or current working directory
 * @param blueprintPath - The path of the blueprint file or directory
 * @returns The path, file name, and extension of the blueprint file
 */
export function findBlueprintFile(blueprintPath) {
    let dirToSearch = cwd();
    if (blueprintPath) {
        const pathExists = existsSync(blueprintPath);
        if (!pathExists)
            return null;
        const stat = statSync(blueprintPath);
        if (stat.isFile()) {
            return {
                blueprintFilePath: blueprintPath,
                fileName: basename(blueprintPath),
                extension: extname(blueprintPath),
            };
        }
        if (stat.isDirectory()) {
            dirToSearch = blueprintPath;
        }
    }
    const blueprintFile = findUpSync(SUPPORTED_FILE_NAMES_IN_PRIORITY_ORDER, {
        cwd: dirToSearch,
        type: 'file',
        allowSymlinks: false,
    });
    if (!blueprintFile)
        return null;
    return {
        blueprintFilePath: blueprintFile,
        fileName: basename(blueprintFile),
        extension: extname(blueprintFile),
    };
}
/**
 * Reads the blueprint file from disk and parses it. Greedily looks for project and stack config
 * @param blueprintPath - The path of the blueprint file or directory- will search up the directory tree!
 * @returns Known information about the Blueprint, config, and Stack
 */
export async function readLocalBlueprint(blueprintPath) {
    const blueprintFile = findBlueprintFile(blueprintPath);
    if (!blueprintFile)
        throw Error('Could not find Blueprint file! Use the init command.');
    const { blueprintFilePath: foundFilePath, fileName, extension } = blueprintFile;
    let rawBlueprint;
    let blueprintModule;
    try {
        switch (extension) {
            case '.json': {
                const blueprintString = readFileSync(foundFilePath, 'utf8').toString();
                rawBlueprint = JSON.parse(blueprintString);
                break;
            }
            case '.js':
            case '.mjs': {
                const module = await import(foundFilePath);
                blueprintModule = module.default;
                break;
            }
            case '.cjs': {
                const require = createRequire(import.meta.url);
                blueprintModule = require(foundFilePath);
                break;
            }
            case '.ts': {
                try {
                    const { tsImport } = await import('tsx/esm/api');
                    const module = await tsImport(`file://${foundFilePath}`, dirname(foundFilePath));
                    blueprintModule = module.default;
                }
                catch (err) {
                    if (err instanceof Error && err.message.includes('Cannot find module')) {
                        throw Error(`TypeScript support requires 'tsx' to be installed. Run: npm install -D tsx`);
                    }
                    throw err;
                }
                break;
            }
            default:
                throw Error(`Unsupported blueprint file extension: ${extension}`);
        }
    }
    catch (err) {
        throw Error(`Error parsing Blueprint file: ${fileName}`);
    }
    if (blueprintModule) {
        if (typeof blueprintModule !== 'function')
            throw Error(`Blueprint ${fileName} must export a default function`);
        try {
            rawBlueprint = blueprintModule();
        }
        catch {
            throw Error(`Error executing Blueprint file: ${fileName}`);
        }
    }
    const parserResult = blueprintParserValidator(rawBlueprint);
    const parsedBlueprint = parserResult.blueprint;
    const errors = parserResult.errors || [];
    // further validation - remove once validator is updated
    if (parsedBlueprint.resources) {
        // validate function resources
        const functionResources = parsedBlueprint.resources.filter(isLocalFunctionResource);
        const fnErrors = functionResources.map((r) => validateFunctionResource(r));
        errors.push(...fnErrors.flat());
    }
    const { SANITY_PROJECT_ID: envProjectId, SANITY_BLUEPRINT_STACK_ID: envStackId } = env;
    const configIds = readConfigFile(foundFilePath);
    const configPath = configIds?.configPath;
    let projectId;
    if (envProjectId)
        projectId = envProjectId;
    else if (configIds?.projectId)
        projectId = configIds.projectId;
    let stackId;
    if (envStackId)
        stackId = envStackId;
    else if (configIds?.stackId)
        stackId = configIds.stackId;
    // LAUNCH LIMIT: 1 Stack per Project - infer stackId from projectId
    if (!stackId && projectId)
        stackId = `ST-${projectId}`;
    return {
        fileInfo: { blueprintFilePath: foundFilePath, fileName, extension },
        rawBlueprint: rawBlueprint,
        errors,
        projectId,
        stackId,
        configPath,
        parsedBlueprint,
    };
}
export function writeBlueprintToDisk({ blueprintFilePath, content = DEFAULT_BLUEPRINT_CONTENT, }) {
    const dir = dirname(blueprintFilePath);
    const extension = extname(blueprintFilePath);
    let blueprintContent;
    switch (extension) {
        case '.json': {
            blueprintContent = JSON.stringify(content, null, 2);
            break;
        }
        case '.js':
        case '.mjs':
        case '.ts': {
            blueprintContent = `export default function() {
  return ${JSON.stringify(content, null, 2)}
}`;
            break;
        }
        case '.cjs': {
            blueprintContent = `module.exports = function() {
  return ${JSON.stringify(content, null, 2)}
}`;
            break;
        }
        default: {
            throw Error(`Unsupported blueprint file extension: ${extension}`);
        }
    }
    mkdirSync(dir, { recursive: true });
    writeFileSync(blueprintFilePath, blueprintContent);
    return blueprintContent;
}
export function readConfigFile(blueprintFilePath) {
    if (blueprintFilePath) {
        const blueprintDir = dirname(blueprintFilePath);
        const configPath = join(blueprintDir, BLUEPRINT_DIR, BLUEPRINT_CONFIG_FILE);
        if (existsSync(configPath)) {
            try {
                const config = JSON.parse(readFileSync(configPath, 'utf8'));
                return { configPath, ...config };
            }
            catch (err) {
                return null;
            }
        }
    }
    const configFilePath = join(cwd(), BLUEPRINT_DIR, BLUEPRINT_CONFIG_FILE);
    if (!existsSync(configFilePath))
        return null;
    try {
        const config = JSON.parse(readFileSync(configFilePath, 'utf8'));
        return config || null;
    }
    catch (err) {
        return null;
    }
}
export function writeConfigFile({ blueprintFilePath, projectId, stackId, }) {
    const blueprintDir = blueprintFilePath ? dirname(blueprintFilePath) : cwd();
    const configDir = join(blueprintDir, BLUEPRINT_DIR);
    const configPath = join(configDir, BLUEPRINT_CONFIG_FILE);
    if (!existsSync(configDir)) {
        mkdirSync(configDir, { recursive: true });
    }
    let config = {};
    if (existsSync(configPath)) {
        try {
            config = JSON.parse(readFileSync(configPath, 'utf8'));
        }
        catch (err) {
            // config broken, start fresh
        }
    }
    config.projectId = projectId;
    config.stackId = stackId;
    config.blueprintConfigVersion = BLUEPRINT_CONFIG_VERSION;
    config.updatedAt = Date.now();
    writeFileSync(configPath, JSON.stringify(config, null, 2));
}
export function addResourceToBlueprint({ blueprintFilePath, resource, }) {
    const blueprintFile = findBlueprintFile(blueprintFilePath);
    if (!blueprintFile)
        throw Error('Could not find Blueprint file');
    const { blueprintFilePath: foundPath, extension } = blueprintFile;
    // modify .json files directly
    if (extension === '.json') {
        const blueprintString = readFileSync(foundPath, 'utf8').toString();
        const blueprint = JSON.parse(blueprintString);
        blueprint.resources = blueprint.resources || [];
        blueprint.resources.push(resource);
        writeFileSync(foundPath, JSON.stringify(blueprint, null, 2));
        return;
    }
    return resource;
}
export function updateBlueprintMetadata({ blueprintFilePath, metadata, }) {
    const blueprintFile = findBlueprintFile(blueprintFilePath);
    if (!blueprintFile)
        throw Error('Could not find Blueprint file');
    const { blueprintFilePath: foundPath, extension } = blueprintFile;
    if (extension === '.json') {
        const blueprintString = readFileSync(foundPath, 'utf8').toString();
        const blueprint = JSON.parse(blueprintString);
        blueprint.metadata = blueprint.metadata || {};
        blueprint.metadata = { ...blueprint.metadata, ...metadata };
        writeFileSync(foundPath, JSON.stringify(blueprint, null, 2));
    }
}
export function updateBlueprintValues({ blueprintFilePath, values, }) {
    const blueprintFile = findBlueprintFile(blueprintFilePath);
    if (!blueprintFile)
        throw Error('Could not find Blueprint file');
    const { blueprintFilePath: foundPath, extension } = blueprintFile;
    if (extension === '.json') {
        const blueprintString = readFileSync(foundPath, 'utf8').toString();
        const blueprint = JSON.parse(blueprintString);
        blueprint.values = blueprint.values || {};
        blueprint.values = { ...blueprint.values, ...values };
        writeFileSync(foundPath, JSON.stringify(blueprint, null, 2));
    }
}
