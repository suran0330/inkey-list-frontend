import { spawn } from 'node:child_process';
import { performance } from 'node:perf_hooks';
import { cwd } from 'node:process';
import { setTimeout } from 'node:timers';
import { fileURLToPath } from 'node:url';
import * as groq from 'groq-js';
import config from '../config.js';
import { bundleFunction } from './bundle/bundle-function.js';
import { findFunctionEntryPoint } from './functions/find-entry-point.js';
import { shouldBundleFunction } from './functions/should-bundle.js';
function getChildProcessWrapperPath() {
    return fileURLToPath(new URL('./child-process-wrapper.js', import.meta.url));
}
export function sanitizeLogs(logs) {
    return logs.replace(/([a-zA-Z0-9]{10})[a-zA-Z0-9]{65,}/g, '$1**********');
}
export const DEFAULT_GROQ_RULE = { on: ['publish'], filter: '', projection: '' };
export function isDefaultGROQRule(rule) {
    if (!rule)
        return true;
    return (Array.isArray(rule.on) &&
        rule.on.length === DEFAULT_GROQ_RULE.on.length &&
        rule.on.every((v) => DEFAULT_GROQ_RULE.on.includes(v)) &&
        rule.filter === DEFAULT_GROQ_RULE.filter &&
        rule.projection === DEFAULT_GROQ_RULE.projection);
}
export async function applyGroqRule(resource, data) {
    // If there is no rule set return everything
    if (!resource.event)
        return data;
    // default groq rule is: gimme full doc content. otherwise, parse + eval custom rule
    // applying the GROQ filter may result in a slimmer set of documents
    if (!isDefaultGROQRule(resource.event)) {
        const hasProjection = resource?.event?.projection?.length;
        const projection = hasProjection ? `{${resource?.event?.projection}}` : '';
        const query = `*[${resource?.event?.filter}]${projection}`;
        try {
            const rule = groq.parse(query);
            const queryResults = await groq.evaluate(rule, { dataset: [data] });
            const currentFunctionDocumentSet = await queryResults.get();
            // TODO can this be multiple documents?
            return currentFunctionDocumentSet[0] || {};
        }
        catch (e) {
            // parsing/validating the groq rule we do up front as part of functions HTTP API
            // so this likely would be triggered by evaluating the query, if anything
            throw Error('⚠️ failed parsing/evaluating GROQ rule! Skipping invoke.');
        }
    }
}
export default async function invoke(resource, data, context, options) {
    if (!resource.src) {
        throw new Error(`Function resource "${resource.name}" is missing the 'src' property.`);
    }
    const { forceColor = true, timeout = 10 } = options;
    const filteredData = await applyGroqRule(resource, data);
    let cleanupBundle = async () => { };
    let functionPath = '';
    let bundleTimings = undefined;
    if (await shouldBundleFunction(resource)) {
        const bundleResult = await bundleFunction(resource);
        functionPath = await findFunctionEntryPoint(bundleResult.outputDir);
        bundleTimings = bundleResult.timings;
        cleanupBundle = bundleResult.cleanup;
    }
    else {
        functionPath = await findFunctionEntryPoint(resource.src, resource.displayName ?? resource.name);
    }
    return new Promise((resolve, reject) => {
        let child;
        let timer;
        let executionStart;
        function start() {
            executionStart = performance.now();
            child = spawn('node', ['--enable-source-maps', getChildProcessWrapperPath()], {
                cwd: cwd(),
                stdio: ['inherit', 'inherit', 'inherit', 'ipc'],
                env: { ...process.env, FORCE_COLOR: forceColor ? '1' : '0' },
            });
            child.on('message', (data) => {
                const executionTimeMs = performance.now() - executionStart;
                const { json, logs } = JSON.parse(data.toString());
                shutdown();
                resolve({
                    json,
                    logs: sanitizeLogs(logs),
                    error: undefined,
                    timings: {
                        ...bundleTimings,
                        execute: executionTimeMs,
                    },
                });
            });
            child.on('error', (error) => {
                shutdown();
                reject(new Error(`encountered error ${error.message}`));
            });
            child.on('exit', (code) => {
                const executionTimeMs = performance.now() - executionStart;
                shutdown();
                if (code !== 0) {
                    reject(new Error(`exited with code ${code}`));
                }
                else {
                    resolve({
                        json: {},
                        logs: '',
                        error: undefined,
                        timings: {
                            ...bundleTimings,
                            execute: executionTimeMs,
                        },
                    });
                }
            });
            timer = setTimeout(() => {
                shutdown();
                reject(new Error(`Timed out after hitting its ${timeout}s timeout!`));
            }, timeout * 1000);
            const payload = {
                ...filteredData,
                context: {
                    ...context,
                    clientOptions: {
                        ...context.clientOptions,
                        apiHost: config.apiUrl,
                        token: config.token,
                    },
                },
            };
            child.send(JSON.stringify({ srcPath: functionPath, payload }, null, 2));
        }
        function shutdown() {
            clearTimeout(timer);
            if (child && !child.killed) {
                child.kill();
            }
            cleanupBundle().catch((err) => console.warn('Bundle cleanup failed:', err));
        }
        start();
    });
}
