{"version":3,"file":"selector.is-selection-expanded.js","sources":["../../src/selectors/selector.is-selection-collapsed.ts","../../src/selectors/selectors.ts","../../src/selectors/selector.get-selection-start-point.ts","../../src/selectors/selector.get-previous-inline-object.ts","../../src/selectors/selector.get-selected-slice.ts","../../src/selectors/selector.get-selection-text.ts","../../src/selectors/selector.is-selection-expanded.ts"],"sourcesContent":["import type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const isSelectionCollapsed: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  return (\n    JSON.stringify(snapshot.context.selection.anchor.path) ===\n      JSON.stringify(snapshot.context.selection.focus.path) &&\n    snapshot.context.selection?.anchor.offset ===\n      snapshot.context.selection?.focus.offset\n  )\n}\n","import type {\n  KeyedSegment,\n  PortableTextBlock,\n  PortableTextListBlock,\n  PortableTextObject,\n  PortableTextSpan,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isListBlock, isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\n\n/**\n * @public\n */\nexport const getFocusBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const key = snapshot.context.selection\n    ? isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? snapshot.context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusListBlock: EditorSelector<\n  {node: PortableTextListBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n\n  return focusTextBlock && isListBlock(snapshot.context, focusTextBlock.node)\n    ? {node: focusTextBlock.node, path: focusTextBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && isTextBlock(snapshot.context, focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusBlockObject: EditorSelector<\n  {node: PortableTextObject; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && !isTextBlock(snapshot.context, focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusTextBlock(snapshot)\n\n  if (!focusBlock) {\n    return undefined\n  }\n\n  const key = snapshot.context.selection\n    ? isKeyedSegment(snapshot.context.selection.focus.path[2])\n      ? snapshot.context.selection.focus.path[2]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? focusBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...focusBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusSpan: EditorSelector<\n  | {node: PortableTextSpan; path: [KeyedSegment, 'children', KeyedSegment]}\n  | undefined\n> = (snapshot) => {\n  const focusChild = getFocusChild(snapshot)\n\n  return focusChild && isSpan(snapshot.context, focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFirstBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[0]\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getLastBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[snapshot.context.value.length - 1]\n    ? snapshot.context.value[snapshot.context.value.length - 1]\n    : undefined\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectedBlocks: EditorSelector<\n  Array<{node: PortableTextBlock; path: [KeyedSegment]}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks: Array<{node: PortableTextBlock; path: [KeyedSegment]}> =\n    []\n  const startKey = snapshot.context.selection.backward\n    ? isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n    : isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n  const endKey = snapshot.context.selection.backward\n    ? isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n    : isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n\n  if (!startKey || !endKey) {\n    return selectedBlocks\n  }\n\n  for (const block of snapshot.context.value) {\n    if (block._key === startKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n      break\n    }\n\n    if (selectedBlocks.length > 0) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n    }\n  }\n\n  return selectedBlocks\n}\n\n/**\n * @public\n */\nexport const getSelectionStartBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const key = snapshot.context.selection.backward\n    ? isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n    : isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n\n  const node = key\n    ? snapshot.context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectionEndBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const key = snapshot.context.selection.backward\n    ? isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n    : isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n\n  const node = key\n    ? snapshot.context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getPreviousBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  let previousBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionStartBlock = getSelectionStartBlock(snapshot)\n\n  if (!selectionStartBlock) {\n    return undefined\n  }\n\n  let foundSelectionStartBlock = false\n\n  for (const block of snapshot.context.value) {\n    if (block._key === selectionStartBlock.node._key) {\n      foundSelectionStartBlock = true\n      break\n    }\n\n    previousBlock = {node: block, path: [{_key: block._key}]}\n  }\n\n  if (foundSelectionStartBlock && previousBlock) {\n    return previousBlock\n  }\n\n  return undefined\n}\n\n/**\n * @public\n */\nexport const getNextBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  let nextBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionEndBlock = getSelectionEndBlock(snapshot)\n\n  if (!selectionEndBlock) {\n    return undefined\n  }\n\n  let foundSelectionEndBlock = false\n\n  for (const block of snapshot.context.value) {\n    if (block._key === selectionEndBlock.node._key) {\n      foundSelectionEndBlock = true\n      continue\n    }\n\n    if (foundSelectionEndBlock) {\n      nextBlock = {node: block, path: [{_key: block._key}]}\n      break\n    }\n  }\n\n  if (foundSelectionEndBlock && nextBlock) {\n    return nextBlock\n  }\n\n  return undefined\n}\n","import type {EditorSelectionPoint} from '..'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getSelectionStartPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n}\n","import {\n  isKeySegment,\n  type KeyedSegment,\n  type PortableTextObject,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan} from '../utils'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getPreviousInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartPointChildKey =\n    selectionStartPoint && isKeySegment(selectionStartPoint.path[2])\n      ? selectionStartPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionStartPointChildKey) {\n    return undefined\n  }\n\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (!isSpan(snapshot.context, child)) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n    }\n  }\n\n  return inlineObject\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {sliceBlocks} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectedSlice: EditorSelector<Array<PortableTextBlock>> = (\n  snapshot,\n) => {\n  return sliceBlocks({\n    context: snapshot.context,\n    blocks: snapshot.context.value,\n  })\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport {getSelectedSlice} from './selector.get-selected-slice'\n\n/**\n * @public\n */\nexport const getSelectionText: EditorSelector<string> = (snapshot) => {\n  const selectedSlice = getSelectedSlice(snapshot)\n\n  return selectedSlice.reduce((text, block) => {\n    if (!isTextBlock(snapshot.context, block)) {\n      return text\n    }\n\n    return (\n      text +\n      block.children.reduce((text, child) => {\n        if (isSpan(snapshot.context, child)) {\n          return text + child.text\n        }\n\n        return text\n      }, '')\n    )\n  }, '')\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport const isSelectionExpanded: EditorSelector<boolean> = (snapshot) => {\n  return !isSelectionCollapsed(snapshot)\n}\n"],"names":["isSelectionCollapsed","snapshot","context","selection","JSON","stringify","anchor","path","focus","offset","getFocusBlock","key","isKeyedSegment","_key","undefined","node","value","find","block","getFocusListBlock","focusTextBlock","getFocusTextBlock","isListBlock","focusBlock","isTextBlock","getFocusBlockObject","getFocusChild","children","span","getFocusSpan","focusChild","isSpan","getFirstBlock","getLastBlock","length","getSelectedBlocks","selectedBlocks","startKey","backward","endKey","push","getSelectionStartBlock","getSelectionEndBlock","getPreviousBlock","previousBlock","selectionStartBlock","foundSelectionStartBlock","getNextBlock","nextBlock","selectionEndBlock","foundSelectionEndBlock","getSelectionStartPoint","getPreviousInlineObject","selectionStartPoint","selectionStartPointChildKey","isKeySegment","inlineObject","child","getSelectedSlice","sliceBlocks","blocks","getSelectionText","reduce","text","isSelectionExpanded"],"mappings":"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"}