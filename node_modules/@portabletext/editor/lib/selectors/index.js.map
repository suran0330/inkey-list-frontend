{"version":3,"file":"index.js","sources":["../../src/selectors/selector.get-anchor-block.ts","../../src/selectors/selector.get-anchor-text-block.ts","../../src/selectors/selector.get-anchor-child.ts","../../src/selectors/selector.get-anchor-span.ts","../../src/selectors/selector.get-block-offsets.ts","../../src/selectors/selector.get-list-state.ts","../../src/selectors/selector.get-selection.ts","../../src/selectors/selector.get-value.ts"],"sourcesContent":["import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isKeyedSegment} from '../utils'\n\n/**\n * @public\n */\nexport const getAnchorBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const key = snapshot.context.selection\n    ? isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? snapshot.context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n","import type {KeyedSegment, PortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getAnchorBlock} from './selector.get-anchor-block'\n\n/**\n * @public\n */\nexport const getAnchorTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const anchorBlock = getAnchorBlock(snapshot)\n\n  return anchorBlock && isTextBlock(snapshot.context, anchorBlock.node)\n    ? {node: anchorBlock.node, path: anchorBlock.path}\n    : undefined\n}\n","import type {KeyedSegment} from '@portabletext/patches'\nimport type {PortableTextObject, PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isKeyedSegment} from '../utils'\nimport {getAnchorTextBlock} from './selector.get-anchor-text-block'\n\n/**\n * @public\n */\nexport const getAnchorChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const anchorBlock = getAnchorTextBlock(snapshot)\n\n  if (!anchorBlock) {\n    return undefined\n  }\n\n  const key = snapshot.context.selection\n    ? isKeyedSegment(snapshot.context.selection.anchor.path[2])\n      ? snapshot.context.selection.anchor.path[2]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? anchorBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...anchorBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n","import type {KeyedSegment} from '@portabletext/patches'\nimport {isPortableTextSpan, type PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getAnchorChild} from './selector.get-anchor-child'\n\n/**\n * @public\n */\nexport const getAnchorSpan: EditorSelector<\n  | {node: PortableTextSpan; path: [KeyedSegment, 'children', KeyedSegment]}\n  | undefined\n> = (snapshot) => {\n  const anchorChild = getAnchorChild(snapshot)\n\n  return anchorChild && isPortableTextSpan(anchorChild.node)\n    ? {node: anchorChild.node, path: anchorChild.path}\n    : undefined\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockOffset} from '../types/block-offset'\nimport * as utils from '../utils'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getBlockOffsets: EditorSelector<\n  {start: BlockOffset; end: BlockOffset} | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n\n  if (!selectionStartPoint || !selectionEndPoint) {\n    return undefined\n  }\n\n  const start = utils.spanSelectionPointToBlockOffset({\n    context: snapshot.context,\n    selectionPoint: selectionStartPoint,\n  })\n  const end = utils.spanSelectionPointToBlockOffset({\n    context: snapshot.context,\n    selectionPoint: selectionEndPoint,\n  })\n\n  return start && end ? {start, end} : undefined\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport type {BlockPath} from '../types/paths'\nimport {getFocusTextBlock, getPreviousBlock} from './selectors'\n\n/**\n * @beta\n * Given the `path` of a block, this selector will return the \"list index\" of\n * the block.\n */\nexport function getListIndex({\n  path,\n}: {\n  path: BlockPath\n}): EditorSelector<number | undefined> {\n  return (snapshot) => {\n    const selection = {\n      anchor: {\n        path,\n        offset: 0,\n      },\n      focus: {\n        path,\n        offset: 0,\n      },\n    }\n\n    const focusTextBlock = getFocusTextBlock({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    if (!focusTextBlock) {\n      return undefined\n    }\n\n    if (\n      focusTextBlock.node.listItem === undefined ||\n      focusTextBlock.node.level === undefined\n    ) {\n      return undefined\n    }\n\n    const previousListItem = getPreviousListItem({\n      listItem: focusTextBlock.node.listItem,\n      level: focusTextBlock.node.level,\n    })({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    if (!previousListItem) {\n      return 1\n    }\n\n    if (previousListItem.node.listItem !== focusTextBlock.node.listItem) {\n      return 1\n    }\n\n    if (\n      previousListItem.node.level !== undefined &&\n      previousListItem.node.level < focusTextBlock.node.level\n    ) {\n      return 1\n    }\n\n    const previousListItemListState = getListIndex({\n      path: previousListItem.path,\n    })(snapshot)\n\n    if (previousListItemListState === undefined) {\n      return 1\n    }\n\n    return previousListItemListState + 1\n  }\n}\n\nfunction getPreviousListItem({\n  listItem,\n  level,\n}: {\n  listItem: string\n  level: number\n}): EditorSelector<\n  | {\n      node: PortableTextTextBlock\n      path: [{_key: string}]\n    }\n  | undefined\n> {\n  return (snapshot) => {\n    const previousBlock = getPreviousBlock({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n      },\n    })\n\n    if (!previousBlock) {\n      return undefined\n    }\n\n    if (!isTextBlock(snapshot.context, previousBlock.node)) {\n      return undefined\n    }\n\n    if (\n      previousBlock.node.listItem === undefined ||\n      previousBlock.node.level === undefined\n    ) {\n      return undefined\n    }\n\n    if (previousBlock.node.listItem !== listItem) {\n      return undefined\n    }\n\n    if (previousBlock.node.level === level) {\n      return {\n        node: previousBlock.node,\n        path: previousBlock.path,\n      }\n    }\n\n    if (previousBlock.node.level < level) {\n      return undefined\n    }\n\n    return getPreviousListItem({\n      listItem,\n      level,\n    })({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: {\n            path: previousBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: previousBlock.path,\n            offset: 0,\n          },\n        },\n      },\n    })\n  }\n}\n","import type {EditorSelection} from '..'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getSelection: EditorSelector<EditorSelection> = (snapshot) => {\n  return snapshot.context.selection\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getValue: EditorSelector<Array<PortableTextBlock>> = (\n  snapshot,\n) => {\n  return snapshot.context.value\n}\n"],"names":["getAnchorBlock","snapshot","key","context","selection","isKeyedSegment","anchor","path","_key","undefined","node","value","find","block","getAnchorTextBlock","anchorBlock","isTextBlock","getAnchorChild","children","span","getAnchorSpan","anchorChild","isPortableTextSpan","getBlockOffsets","selectionStartPoint","getSelectionStartPoint","selectionEndPoint","getSelectionEndPoint","start","utils","selectionPoint","end","getListIndex","offset","focus","focusTextBlock","getFocusTextBlock","listItem","level","previousListItem","getPreviousListItem","previousListItemListState","previousBlock","getPreviousBlock","getSelection","getValue"],"mappings":"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"}