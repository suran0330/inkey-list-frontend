import { getSelectionEndPoint } from "../_chunks-es/selector.is-selecting-entire-blocks.js";
import { getActiveAnnotations, getActiveListItem, getActiveStyle, getCaretWordSelection, getFocusInlineObject, getNextInlineObject, getSelectedSpans, getSelectedTextBlocks, getTrimmedSelection, isActiveAnnotation, isActiveDecorator, isActiveListItem, isActiveStyle, isAtTheEndOfBlock, isAtTheStartOfBlock, isOverlappingSelection, isPointAfterSelection, isPointBeforeSelection, isSelectingEntireBlocks } from "../_chunks-es/selector.is-selecting-entire-blocks.js";
import { isKeyedSegment, isTextBlock, spanSelectionPointToBlockOffset } from "../_chunks-es/util.slice-blocks.js";
import { isPortableTextSpan } from "@sanity/types";
import { getSelectionStartPoint, getFocusTextBlock, getPreviousBlock } from "../_chunks-es/selector.is-selection-expanded.js";
import { getFirstBlock, getFocusBlock, getFocusBlockObject, getFocusChild, getFocusListBlock, getFocusSpan, getLastBlock, getNextBlock, getPreviousInlineObject, getSelectedBlocks, getSelectedSlice, getSelectionEndBlock, getSelectionStartBlock, getSelectionText, isSelectionCollapsed, isSelectionExpanded } from "../_chunks-es/selector.is-selection-expanded.js";
import { getBlockTextBefore } from "../_chunks-es/selector.get-text-before.js";
const getAnchorBlock = (snapshot) => {
  const key = snapshot.context.selection && isKeyedSegment(snapshot.context.selection.anchor.path[0]) ? snapshot.context.selection.anchor.path[0]._key : void 0, node = key ? snapshot.context.value.find((block) => block._key === key) : void 0;
  return node && key ? {
    node,
    path: [{
      _key: key
    }]
  } : void 0;
}, getAnchorTextBlock = (snapshot) => {
  const anchorBlock = getAnchorBlock(snapshot);
  return anchorBlock && isTextBlock(snapshot.context, anchorBlock.node) ? {
    node: anchorBlock.node,
    path: anchorBlock.path
  } : void 0;
}, getAnchorChild = (snapshot) => {
  const anchorBlock = getAnchorTextBlock(snapshot);
  if (!anchorBlock)
    return;
  const key = snapshot.context.selection && isKeyedSegment(snapshot.context.selection.anchor.path[2]) ? snapshot.context.selection.anchor.path[2]._key : void 0, node = key ? anchorBlock.node.children.find((span) => span._key === key) : void 0;
  return node && key ? {
    node,
    path: [...anchorBlock.path, "children", {
      _key: key
    }]
  } : void 0;
}, getAnchorSpan = (snapshot) => {
  const anchorChild = getAnchorChild(snapshot);
  return anchorChild && isPortableTextSpan(anchorChild.node) ? {
    node: anchorChild.node,
    path: anchorChild.path
  } : void 0;
}, getBlockOffsets = (snapshot) => {
  if (!snapshot.context.selection)
    return;
  const selectionStartPoint = getSelectionStartPoint(snapshot), selectionEndPoint = getSelectionEndPoint(snapshot);
  if (!selectionStartPoint || !selectionEndPoint)
    return;
  const start = spanSelectionPointToBlockOffset({
    context: snapshot.context,
    selectionPoint: selectionStartPoint
  }), end = spanSelectionPointToBlockOffset({
    context: snapshot.context,
    selectionPoint: selectionEndPoint
  });
  return start && end ? {
    start,
    end
  } : void 0;
};
function getListIndex({
  path
}) {
  return (snapshot) => {
    const selection = {
      anchor: {
        path,
        offset: 0
      },
      focus: {
        path,
        offset: 0
      }
    }, focusTextBlock = getFocusTextBlock({
      context: {
        ...snapshot.context,
        selection
      }
    });
    if (!focusTextBlock || focusTextBlock.node.listItem === void 0 || focusTextBlock.node.level === void 0)
      return;
    const previousListItem = getPreviousListItem({
      listItem: focusTextBlock.node.listItem,
      level: focusTextBlock.node.level
    })({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection
      }
    });
    if (!previousListItem || previousListItem.node.listItem !== focusTextBlock.node.listItem || previousListItem.node.level !== void 0 && previousListItem.node.level < focusTextBlock.node.level)
      return 1;
    const previousListItemListState = getListIndex({
      path: previousListItem.path
    })(snapshot);
    return previousListItemListState === void 0 ? 1 : previousListItemListState + 1;
  };
}
function getPreviousListItem({
  listItem,
  level
}) {
  return (snapshot) => {
    const previousBlock = getPreviousBlock({
      context: {
        ...snapshot.context
      }
    });
    if (previousBlock && isTextBlock(snapshot.context, previousBlock.node) && !(previousBlock.node.listItem === void 0 || previousBlock.node.level === void 0) && previousBlock.node.listItem === listItem) {
      if (previousBlock.node.level === level)
        return {
          node: previousBlock.node,
          path: previousBlock.path
        };
      if (!(previousBlock.node.level < level))
        return getPreviousListItem({
          listItem,
          level
        })({
          ...snapshot,
          context: {
            ...snapshot.context,
            selection: {
              anchor: {
                path: previousBlock.path,
                offset: 0
              },
              focus: {
                path: previousBlock.path,
                offset: 0
              }
            }
          }
        });
    }
  };
}
const getSelection = (snapshot) => snapshot.context.selection, getValue = (snapshot) => snapshot.context.value;
export {
  getActiveAnnotations,
  getActiveListItem,
  getActiveStyle,
  getAnchorBlock,
  getAnchorChild,
  getAnchorSpan,
  getAnchorTextBlock,
  getBlockOffsets,
  getBlockTextBefore,
  getCaretWordSelection,
  getFirstBlock,
  getFocusBlock,
  getFocusBlockObject,
  getFocusChild,
  getFocusInlineObject,
  getFocusListBlock,
  getFocusSpan,
  getFocusTextBlock,
  getLastBlock,
  getListIndex,
  getNextBlock,
  getNextInlineObject,
  getPreviousBlock,
  getPreviousInlineObject,
  getSelectedBlocks,
  getSelectedSlice,
  getSelectedSpans,
  getSelectedTextBlocks,
  getSelection,
  getSelectionEndBlock,
  getSelectionEndPoint,
  getSelectionStartBlock,
  getSelectionStartPoint,
  getSelectionText,
  getTrimmedSelection,
  getValue,
  isActiveAnnotation,
  isActiveDecorator,
  isActiveListItem,
  isActiveStyle,
  isAtTheEndOfBlock,
  isAtTheStartOfBlock,
  isOverlappingSelection,
  isPointAfterSelection,
  isPointBeforeSelection,
  isSelectingEntireBlocks,
  isSelectionCollapsed,
  isSelectionExpanded
};
//# sourceMappingURL=index.js.map
